Hello
🔹 Arrays: Sliding window, two pointers, binary search, sorting, greedy algorithms
🔹 Strings: Palindromes, pattern matching
🔹 Stacks & Queues: Next greater/smaller element, BFS, flood fill
🔹 Trees: Binary trees, BSTs, traversals
🔹 Graphs: DFS, BFS, Dijkstra's, MST (Prim's/Kruskal's), DSU
🔹 Heaps: Min/Max heap, Kth smallest/largest element
🔹 Recursion & Backtracking (very very important): Permutations and combinations.

𝟏. 𝐒𝐥𝐢𝐝𝐢𝐧𝐠 𝐖𝐢𝐧𝐝𝐨𝐰 (e.g., Longest Substring Without Repeating Characters)
𝟐. 𝐓𝐰𝐨 𝐏𝐨𝐢𝐧𝐭𝐞𝐫𝐬 (e.g., 3Sum, Container With Most Water)
𝟑. 𝐅𝐚𝐬𝐭 & 𝐒𝐥𝐨𝐰 𝐏𝐨𝐢𝐧𝐭𝐞𝐫𝐬 (e.g., Linked List Cycle)
𝟒. 𝐌𝐞𝐫𝐠𝐞 𝐈𝐧𝐭𝐞𝐫𝐯𝐚𝐥𝐬 (e.g., Meeting Rooms II)
𝟓. 𝐂𝐲𝐜𝐥𝐢𝐜 𝐒𝐨𝐫𝐭 (e.g., Find Missing Number)
𝟔. 𝐈𝐧-𝐩𝐥𝐚𝐜𝐞 𝐑𝐞𝐯𝐞𝐫𝐬𝐚𝐥 𝐨𝐟 𝐚 𝐋𝐢𝐧𝐤𝐞𝐝 𝐋𝐢𝐬𝐭 (e.g., Reverse a Linked List, Reverse Nodes in k-Group)
𝟕. 𝐓𝐫𝐞𝐞 𝐁𝐅𝐒/𝐃𝐅𝐒 (e.g., Binary Tree Right Side View)
𝟖. 𝐁𝐢𝐧𝐚𝐫𝐲 𝐒𝐞𝐚𝐫𝐜𝐡 (e.g., Find Peak Element)
𝟗. 𝐁𝐚𝐜𝐤𝐭𝐫𝐚𝐜𝐤𝐢𝐧𝐠 (e.g., N-Queens, Subsets)
𝟏𝟎. 𝐇𝐞𝐚𝐩 (𝐏𝐫𝐢𝐨𝐫𝐢𝐭𝐲 𝐐𝐮𝐞𝐮𝐞) (e.g., Kth Largest Element in an Array)
𝟏𝟏. 𝐓𝐫𝐢𝐞 (𝐏𝐫𝐞𝐟𝐢𝐱 𝐓𝐫𝐞𝐞) (e.g., Word Search II, Implement Trie)
𝟏𝟐. 𝐆𝐫𝐚𝐩𝐡 𝐓𝐫𝐚𝐯𝐞𝐫𝐬𝐚𝐥 (𝐁𝐅𝐒/𝐃𝐅𝐒) (e.g., Word Ladder, Number of Islands)
𝟏𝟑. 𝐔𝐧𝐢𝐨𝐧-𝐅𝐢𝐧𝐝 (𝐃𝐢𝐬𝐣𝐨𝐢𝐧𝐭 𝐒𝐞𝐭) (e.g., Redundant Connection)
𝟏𝟒. 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 (𝐃𝐏) (e.g., Longest Increasing Subsequence, House Robber)
𝟏𝟓. 𝐁𝐢𝐭 𝐌𝐚𝐧𝐢𝐩𝐮𝐥𝐚𝐭𝐢𝐨𝐧 (e.g., Single Number, Counting Bits)





→ Sliding window median
→ Path with maximum probability
→ Dungeons and Princesses
→ Floodfill
→ Minimum cost for tickets
→ Minimum number of refueling stops
→ Subarrays with K different integers
→ Count the number of Nice subarrays
→ Fruit into baskets
→ Koko eating bananas






☑️ 𝐖𝐞𝐞𝐤 𝟏-𝟐: 𝐀𝐫𝐫𝐚𝐲𝐬, 𝐒𝐭𝐫𝐢𝐧𝐠𝐬, 𝐌𝐚𝐭𝐡 – Prefix sum, sliding window, two pointers, hashing
☑️ 𝐖𝐞𝐞𝐤 𝟑-𝟒: 𝐋𝐢𝐧𝐤𝐞𝐝 𝐋𝐢𝐬𝐭, 𝐒𝐭𝐚𝐜𝐤, 𝐐𝐮𝐞𝐮𝐞 – Singly/doubly LL, fast-slow pointers, stack with min/max, queue variations
☑️ 𝐖𝐞𝐞𝐤 𝟓: 𝐓𝐫𝐞𝐞𝐬 & 𝐁𝐢𝐧𝐚𝐫𝐲 𝐓𝐫𝐞𝐞𝐬 – Preorder/Inorder/Postorder, BFS/DFS, diameter, balanced trees
☑️ 𝐖𝐞𝐞𝐤 𝟔: 𝐁𝐒𝐓 & 𝐓𝐫𝐢𝐞𝐬 – Floor/Ceil, kth smallest, delete in BST, prefix search
☑️ 𝐖𝐞𝐞𝐤 𝟕: 𝐑𝐞𝐜𝐮𝐫𝐬𝐢𝐨𝐧 & 𝐁𝐚𝐜𝐤𝐭𝐫𝐚𝐜𝐤𝐢𝐧𝐠 – Subsets, permutations, N-Queens, Sudoku solver
☑️ 𝐖𝐞𝐞𝐤 𝟖: 𝐇𝐞𝐚𝐩𝐬 & 𝐏𝐫𝐢𝐨𝐫𝐢𝐭𝐲 𝐐𝐮𝐞𝐮𝐞 – Median of stream, Top K elements, custom comparator
☑️ 𝐖𝐞𝐞𝐤 𝟗: 𝐆𝐫𝐚𝐩𝐡𝐬 (𝐁𝐅𝐒, 𝐃𝐅𝐒) – Detect cycle, connected components, bipartite, topological sort
☑️ 𝐖𝐞𝐞𝐤 𝟏𝟎: 𝐆𝐫𝐚𝐩𝐡𝐬 (𝐀𝐝𝐯𝐚𝐧𝐜𝐞𝐝) – Dijkstra, Prim’s, Kruskal’s, Union Find, shortest path variants
☑️ 𝐖𝐞𝐞𝐤 𝟏𝟏: 𝐃𝐲𝐧𝐚𝐦𝐢𝐜 𝐏𝐫𝐨𝐠𝐫𝐚𝐦𝐦𝐢𝐧𝐠 – 1D DP (Linear DP), 2D/Matrix DP, DP on Strings, Subsequences, Bitmask DP, Trees, Graphs, Interval DP, MCM Problems, Game Theory DP





1️⃣ Merge Intervals
2️⃣ Koko Eating Bananas
3️⃣ Search in Rotated Sorted Array
4️⃣ Detect a Cycle in Linked List
5️⃣ Word Search II
6️⃣ Gas Station
7️⃣ Sliding Window Maximum
8️⃣ Coin Change
9️⃣ Word Break
🔟 Edit Distance
1️⃣1️⃣ Trapping Rainwater
1️⃣2️⃣ Largest Rectangle in a Histogram
1️⃣3️⃣ Rod Cutting
1️⃣4️⃣ Binary Tree Maximum Path Sum
1️⃣5️⃣ Number of Distinct Islands
1️⃣6️⃣ Rotten Oranges
1️⃣7️⃣ Course Schedule II
1️⃣8️⃣ Pacific Atlantic Water Flow
1️⃣9️⃣ Cheapest Flights Within K Stops
2️⃣0️⃣ Min Cost to Connect All Points









40 most

➤ 𝗔𝗿𝗿𝗮𝘆𝘀 𝗮𝗻𝗱 𝗦𝘁𝗿𝗶𝗻𝗴𝘀:
 1. Find the maximum sum subarray.
 2. Find all substrings that are palindromes.
 3. Implement the "two sum" problem.
 4. Implement Kadane's algorithm for maximum subarray sum.
 5. Find the missing number in an array of integers.
 6. Merge two sorted arrays into one sorted array.
 7. Check if a string is a palindrome.
 8. Find the first non-repeating character in a string.
 9. Write a program to remove duplicates from a sorted array.

➤ 𝗟𝗶𝗻𝗸𝗲𝗱 𝗟𝗶𝘀𝘁𝘀:
 10. Reverse a linked list.
 11. Detect a cycle in a linked list.
 12. Find the middle of a linked list.
 13. Merge two sorted linked lists.
 14. Implement a stack using a linked list.
 15. Find the intersection point of two linked lists.

➤ 𝗦𝘁𝗮𝗰𝗸𝘀 𝗮𝗻𝗱 𝗤𝘂𝗲𝘂𝗲𝘀:
 16. Implement a stack using an array.
 17. Implement a stack that supports push, pop, top, and retrieving the minimum element.
 18. Implement a circular queue.
 19. Design a max stack that supports push, pop, top, and retrieve the maximum element.
 20. Design a queue using stacks.

➤ 𝗧𝗿𝗲𝗲𝘀 𝗮𝗻𝗱 𝗕𝗶𝗻𝗮𝗿𝘆 𝗦𝗲𝗮𝗿𝗰𝗵 𝗧𝗿𝗲𝗲𝘀:
 21. Find the height of a binary tree.
 22. Find the lowest common ancestor of two nodes in a binary tree.
 23. Validate if a binary tree is a valid binary search tree.
 24. Serialize and deserialize a binary tree.
 25. Implement an inorder traversal of a binary tree.
 26. Find the diameter of a binary tree.
 27. Convert a binary tree to its mirror tree.

➤ 𝗚𝗿𝗮𝗽𝗵𝘀:
 28. Implement depth-first search (DFS).
 29. Implement breadth-first search (BFS).
 30. Find the shortest path between two nodes in an unweighted graph.
 31. Detect a cycle in an undirected graph using DFS.
 32. Check if a graph is bipartite.
 33. Find the number of connected components in an undirected graph.
 34. Find bridges in a graph.

➤ 𝗦𝗼𝗿𝘁𝗶𝗻𝗴 𝗮𝗻𝗱 𝗦𝗲𝗮𝗿𝗰𝗵𝗶𝗻𝗴:
 35. Implement (bubble, insertion, selection, merge) sort.
 36. Implement quicksort.
 37. Implement binary search.
 38. Implement interpolation search.
 39. Find the kth smallest element in an array.
 40. Given an array of integers, count the number of inversions it has. An inversion occurs when two elements in the array are out of order.